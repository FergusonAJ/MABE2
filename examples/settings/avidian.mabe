random_seed = 0;                // Seed for random number generator; use 0 to base on time.
Population main_pop;            // Collection of organisms
Population next_pop;            // Collection of organisms

Value pop_size = 100;

CommandLine cl {                // Handle basic I/O on the command line.
  target_pop = "main_pop";      // Which population should we print stats about?
}
//EvalTaskNot eval_task{
//  target = "main_pop";
//  outputs_trait = "outputs";
//  fitness_trait = "fitness";
//}
EvalTaskMax eval_task{
  outputs_trait = "outputs";
  fitness_trait = "fitness";
}
SchedulerProbabilistic scheduler {
  pop = "main_pop";
  trait = "fitness";
  avg_updates = 30;  
}
SelectElite select_e {          // Choose the top fitness organisms for replication.
  select_pop = "main_pop";      // Which population should we select parents from?
  birth_pop = "next_pop";       // Which population should births go into?
  top_count = 1;                // Number of top-fitness orgs to be replicated
  copy_count = 1;               // Number of copies to make of replicated organisms
  fitness_trait = "fitness";    // Which trait provides the fitness value to use?
  Value total_count = top_count * copy_count;
}
SelectTournament select_t {     // Select the top fitness organisms from random subgroups for replication.
  select_pop = "main_pop";      // Which population should we select parents from?
  birth_pop = "next_pop";       // Which population should births go into?
  tournament_size = 2;          // Number of orgs in each tournament

  num_tournaments = pop_size - select_e.total_count;  // Number of tournaments to run
  fitness_trait = "fitness";    // Which trait provides the fitness value to use?
}

RandomReplacement place_next {    // Always appened births to the end of a population.
  target = "main_pop"; // Population(s) to manage.
}

//MovePopulation sync_gen {       // Move organisms from one populaiton to another.
//  from_pop = "next_pop";        // Population to move organisms from.
//  to_pop = "main_pop";          // Population to move organisms into.
//  reset_to = 1;                 // Should we erase organisms at the destination?
//}

AvidaGPOrg gp_orgs {            // Organism consisting of a series of N bits.
  output_name = "bits";         // Name of variable to contain bit sequence.
  base_size = 100;               // Number of instructions in randomly created organisms
  mut_prob = 0.01;          		// Probability of each bit mutating on reproduction.
}
BitsOrg bits_org {              // Organism consisting of a series of N bits.
  output_name = "bits";         // Name of variable to contain bit sequence.
  N = 10;                       // Number of bits in organism
  mut_prob = 0.01;          		// Probability of each bit mutating on reproduction.
}

@start() print("random_seed = ", random_seed, "\n");
@start() inject("gp_orgs", "main_pop", pop_size);
@update(500) select_t.tournament_size = 4;
@update(1000) exit();
